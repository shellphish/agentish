#{ Template for router node - Uses router_values with label mapping #}
def {{ sanitized_label }}_{{ node_id }}_node(global_state: GlobalState) -> Command:
    """Router Node {{ node_id }}: {{ title }}
    
    Decides which node to route to based on LLM analysis with structured output.
    Uses router_values to determine available options.
    """
    
    # Define routing decision schema
    class RouterDecision(BaseModel):
        next_node: str = Field(description="Label of next node to route to")
        reason: str = Field(description="Reasoning for routing decision")
    
    # Build message list
    messages = []
    
    # Add system prompt
    system_prompt_rendered = render_template({{ system_prompt|tojson }}, global_state)
    if system_prompt_rendered:
        messages.append(SystemMessage(content=system_prompt_rendered))
    
    # Get conversation history from global state
    messages.extend(global_state.get("messages", []))
    
    # Build routing prompt with router_values
    routing_prompt = "Based on the conversation so far, choose the most appropriate next node to handle the request.\n\nAvailable routing options:\n"
    
    {%- for rv in router_values %}
    routing_prompt += "- {{ rv.node }}: {{ rv.description }}\n"
    {%- endfor %}
    
    routing_prompt += "\nChoose one of the node labels from the options above."
    
    {%- if input_state_keys %}
    # Add input state keys section
    routing_prompt += "\n\n## Input:\n"
    {%- for key in input_state_keys %}
    routing_prompt += f"\n### {{ key }}:\n{global_state.get('{{ key }}', 'Not available')}\n"
    {%- endfor %}
    {%- endif %}
    
    messages.append(HumanMessage(content=routing_prompt))
    
    # Use structured output
    router_model = model_router_{{ node_id }}.with_structured_output(RouterDecision)
    decision = router_model.invoke(messages)
    
    # Map label to function name
    label_to_func = {{ label_to_function_map|tojson }}
    
    # Validate and get target function
    target_func = label_to_func.get(decision.next_node)
    if not target_func:
        # Fallback to first option if invalid
        target_func = list(label_to_func.values())[0] if label_to_func else "END"
    
    # Create AI message with routing decision
    routing_message = AIMessage(content=f"Routing to {decision.next_node}: {decision.reason}")
    
    # Return Command with routing decision
    return Command(
        update={
            "count": 1,
            "messages": [routing_message],
            "routing_reason": decision.reason
        },
        goto=target_func
    )

