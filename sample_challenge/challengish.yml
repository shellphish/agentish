# Agentish Challenge Configuration
# This file contains Agentish-specific challenge metadata and MCP server definitions

# Challenge identification
challenge_name: "Binary Analysis Challenge"
challenge_id: "binary-analysis-001"

# Detailed description for participants using Agentish
description: |
  Reverse engineer the provided binary to discover the secret password.
  Use the available MCP tools to analyze the binary's functions,
  disassembly, and call graph to understand its behavior.

  Your agent should:
  1. Explore the binary's functions using list_functions
  2. Analyze relevant functions using get_disassembly_by_function
  3. Understand the program flow using call graph tools
  4. Test candidate passwords using run_challenge
  5. Optionally use run_python for custom analysis

# Tags for categorization
tags:
  - "reverse-engineering"
  - "binary-analysis"
  - "password-cracking"

# Hints that can be revealed to participants
hints:
  - "Start by listing all functions to understand the binary structure"
  - "The main function often contains the password check logic"
  - "Look for string comparison functions in the disassembly"

# Success criteria
success_criteria:
  flag_format: "iCTF{...}"
  max_attempts: 100

# Time limits (optional)
time_limits:
  max_execution_time: 600  # seconds
  max_llm_calls: 50

# =============================================================================
# MCP SERVER CONFIGURATION
# =============================================================================

mcp_servers:
  - name: "binary_analysis"
    port: 8002
    internal_host: "mcp_binary"
    service_file: "artifacts/mcp_implementation/mcp_server.py"
    enabled: true
    routes:
      - function: "list_functions"
        endpoint: "/mcp/list_functions"
        method: "GET"
        description: "List all discovered functions from the challenge binary"
        arguments: []
        return_schema:
          success: "bool"
          functions: "list"

      - function: "get_disassembly_by_function"
        endpoint: "/mcp/get_disassembly_by_function"
        method: "GET"
        description: "Fetch the disassembly for a specific function name"
        arguments:
          - name: "function"
            type: "str"
            required: true
            description: "Function name/signature"
        return_schema:
          success: "bool"
          disassembly: "str"

      - function: "get_caller_callee_mapping"
        endpoint: "/mcp/get_caller_callee_mapping"
        method: "GET"
        description: "Return who a function calls within the binary"
        arguments:
          - name: "function_signature"
            type: "str"
            required: true
            description: "Caller function name"
        return_schema:
          success: "bool"
          caller_callee_mapping: "dict"

      - function: "get_callee_caller_mapping"
        endpoint: "/mcp/get_callee_caller_mapping"
        method: "GET"
        description: "Return which functions call the provided callee"
        arguments:
          - name: "function_signature"
            type: "str"
            required: true
            description: "Callee function name"
        return_schema:
          success: "bool"
          callee_caller_mapping: "dict"

      - function: "run_challenge"
        endpoint: "/mcp/run_challenge"
        method: "POST"
        description: "Execute the challenge binary with a candidate password"
        arguments:
          - name: "input"
            type: "str"
            required: true
            description: "Password to test"
        return_schema:
          success: "bool"
          flag: "str"
          output: "str"

      - function: "run_python"
        endpoint: "/mcp/run_python"
        method: "POST"
        description: "Execute a Python snippet inside the challenge sandbox"
        arguments:
          - name: "code"
            type: "str"
            required: true
            description: "Python source to execute"
          - name: "stdin"
            type: "str"
            required: false
            description: "Optional STDIN for the script"
        return_schema:
          success: "bool"
          stdout: "str"
          stderr: "str"
          return_code: "int"
