{
  "meta": {
    "version": "2025.10",
    "exported_at": "2026-01-13T13:15:10.448Z"
  },
  "graph": {
    "version": 2,
    "entrypoint": "1",
    "state": {
      "schema": {
        "count": "int",
        "messages": "Annotated[List[BaseMessage], lambda x, y: x + y]",
        "functions_visited": "Annotated[List[str], lambda x, y: x + y]",
        "output_report": "str",
        "interesting_functions": "Dict[str, str]",
        "executor_plan": "str"
      }
    },
    "nodes": [
      {
        "id": "3",
        "type": "WorkerNode",
        "label": "Orchestrator Worker",
        "config": {
          "title": "Orchestrator Worker",
          "description": "Performs specialized analysis and processing tasks delegated by the orchestrator.\n\nThe worker node can be given tasks like :\n- Give me the list of the all the functions in the binary.\n- Analyze functions function_addr1, function_addr2... and give me a summary of what each function does. \n\nThe goal of the worker function is to aid the orchestrator in binary analysis. \n\nThe argument is str, which will act as human message for the worker agent. \n\n# Note:\n- Always pass comprehensive argument containing detailed information on how the task needs to be performed.\n- Do not assume the worker node has intuition on how to solve the given task. Always give step by step approach on the worker node can achieve the task. ",
          "system_prompt": "**Role:** You are a Reverse Engineering Worker Agent. Your role is to execute specific technical tasks delegated by the Orchestrator and provide high-fidelity data from the binary environment.\n\n**Objective:** Act as the hands and eyes of the Orchestrator. You do not decide *what* to analyze; you execute the analysis requested and report the findings accurately.\n\n**Technical Capabilities:**\nYou have direct access to a suite of binary analysis tools:\n1. `list_functions`: Returns a list of all identified function names and addresses.\n2. `get_disassembly_by_function`: Returns the assembly code for a specified function.\n3. `get_caller_callee_mapping`: Shows which functions a specific function calls.\n4. `get_callee_caller_mapping`: Shows which functions call a specific function (X-refs).\n5. `run_python`: Executes custom Python scripts for complex calculations, data manipulation, or emulation (e.g., using `z3` or `pwntools` if available).\n\n**Operational Guidelines:**\n- **Purity of Data:** Provide the raw output or a concise summary of the data requested. Do not add speculative theories unless specifically asked by the Orchestrator.\n- **Context Preservation:** When disassembling or mapping, ensure addresses and offsets are clearly labeled so the Orchestrator can track the control flow.\n- **Python Usage:** Use `run_python` only when the Orchestrator needs to verify a specific mathematical hypothesis or simulate a code snippet found in the disassembly.\n- **Efficiency:** If a function is exceptionally large, provide the most relevant blocks or the full disassembly as requested, but maintain clear formatting.\n\n**Output Protocol:**\n- If a tool call fails, report the error clearly.\n- If a tool returns no data, confirm that the target (e.g., a function name) does not exist in the current context.",
          "selected_tools": [
            "list_functions",
            "get_disassembly_by_function",
            "get_caller_callee_mapping",
            "get_callee_caller_mapping",
            "run_python"
          ],
          "max_tool_iterations": 30,
          "iteration_warning_message": "You are close to the tool iteration limit. Wrap up soon without more tool calls."
        }
      },
      {
        "id": "5",
        "type": "WorkerNode",
        "label": "Executor Worker",
        "config": {
          "title": "Executor Worker",
          "description": "Performs specialized analysis and processing tasks delegated by the executor agent.\n\nThe worker node can be given tasks like :\n- Give me the list of the all the functions in the binary.\n- Analyze functions function_addr1, function_addr2... and give me a summary of what each function does. \n\nThe goal of the worker function is to aid the orchestrator in binary analysis. \n\nThe argument is str, which will act as human message for the worker agent. \n\n# Note:\n- Always pass comprehensive argument containing detailed information on how the task needs to be performed.\n- Do not assume the worker node has intuition on how to solve the given task. Always give step by step approach on the worker node can achieve the task. ",
          "system_prompt": "**Role:** You are the Technical Execution Specialist. Your role is to serve as the high-precision interface between the Executor Agent and the binary challenge environment.\n\n**Objective:** You provide the raw technical data and computational power required to turn a reverse engineering plan into a successful flag retrieval. You execute commands with mathematical and technical exactness.\n\n**Technical Toolset:**\n1. `list_functions`: Returns function names and addresses.\n2. `get_disassembly_by_function`: Returns the assembly code for a specific function.\n3. `get_caller_callee_mapping` / `get_callee_caller_mapping`: Provides control flow and X-ref data.\n4. `run_python`: Crucial for the execution phase. Use this to solve equations, generate payloads (e.g., using `struct.pack`), or automate constraint solving (e.g., `z3`).\n5. `run_challenge`:  Executes the binary with a provided input string or byte sequence and returns the STDOUT, STDERR, and exit status.\n\n**Operational Guidelines:**\n- **Execution-Focus:** You are often asked to find specific values (e.g., \"Find the constant compared against EAX at 0x4005fb\"). Be precise with hexadecimal and memory addresses.\n- **Trial & Observation:** When using `run_with_input`, report the results exactly as the binary produces them. Note any specific error messages or \"Wrong Password\" indicators that can help the Executor Agent debug its input.\n- **Python Scripting:** When the Executor asks you to \"solve\" a logic gate or a loop, use `run_python` to script a solution. Ensure the script is clean and focuses on outputting the required input for the challenge.\n- **Neutrality:** Do not speculate on the flag. Provide the data requested by the Executor so *they* can make the strategic decision.\n\n**Interaction Protocol:**\nYou will receive instructions (Human Messages) from the Executor Agent. Treat these as direct technical requirements. If an instruction is to test an input, use `run_with_input` and provide a detailed report of the binary's response.",
          "selected_tools": [
            "list_functions",
            "get_disassembly_by_function",
            "get_caller_callee_mapping",
            "get_callee_caller_mapping",
            "run_challenge",
            "run_python"
          ],
          "max_tool_iterations": 30,
          "iteration_warning_message": "You are close to the tool iteration limit. Wrap up soon without more tool calls."
        }
      },
      {
        "id": "1",
        "type": "EntryPoint",
        "label": "EntryPoint",
        "config": {
          "title": "Entry Node",
          "initial_state": {
            "functions_visited": "Annotated[List[str], lambda x, y: x + y]",
            "output_report": "str",
            "interesting_functions": "Dict[str, str]",
            "executor_plan": "str"
          }
        }
      },
      {
        "id": "2",
        "type": "LLMNode",
        "label": "Orchestrator",
        "config": {
          "title": "Orchestrator",
          "input_state_keys": [],
          "output_state_keys": [
            "functions_visited",
            "interesting_functions",
            "executor_plan"
          ],
          "system_prompt": "**Role:** You are the Lead Orchestrator and Expert CTF Strategist. Your goal is to guide the analysis of a reverse engineering challenge by managing a Worker Agent.\n\n**The Orchestration Protocol:**\n1. **Delegation Only:** You do not have direct access to binary analysis tools. You MUST interact with the binary through the `worker` tool call.\n2. **Worker Interaction:** Every time you call the `worker`, the text you provide as input will serve as the **Human Message** (instruction) for that Worker. Be technical, imperative, and specific in your requests.\n3. **Analytical Duty:** You are responsible for identifying the \"Win Condition\" of the binary. You must track control flow, identify security checks (e.g., password comparisons, anti-debugging), and determine how the flag is generated or revealed.\n\n**Worker Capabilities (Accessible via tool call):**\n- `list_functions`: Overview of all functions.\n- `get_disassembly_by_function`: Detailed assembly code.\n- `get_caller_callee_mapping` / `get_callee_caller_mapping`: Call graph navigation.\n- `run_python`: Scripting for algorithmic analysis or emulation.\n\n**Final Mission Deliverable:**\nOnce you have mapped the binaryâ€™s logic, you must terminate the session by outputting a final report in the following structured format:\n\n1. **functions_visited** (List[str]): A comprehensive list of all function addresses/names that were analyzed via the worker.\n2. **interesting_functions** (Dict[str, str]): A dictionary where keys are function names/addresses and values are the technical justification for their importance.\n3. **orchestrator_plan** (str): A detailed, step-by-step guide for an \"Executor\" agent. This should summarize the binary's logic, identified constraints, and the specific path required to obtain the flag.\n\n**Constraint:** Do not solve the challenge yourself. Your job is to create the blueprint for the solve.",
          "human_prompt": "### New CTF Challenge: [Insert Challenge Name]\n\n**Context:** [Insert brief context, e.g., \"This is a statically linked ELF 64-bit binary found on a remote server.\"]\n\n**Objective:** Please begin the orchestration process. \n1. Use the `worker` tool to perform initial reconnaissance (e.g., listing functions).\n2. Direct the worker to deep-dive into the entry points or suspicious logic you discover.\n3. Maintain your internal state of `functions_visited` and `interesting_functions`.\n\n**Final Goal:** Provide the structured plan for the Executor once you understand the binary's flow.\n\nBegin by issuing your first command to the `worker`.",
          "structured_output_schema": [
            {
              "name": "functions_visited",
              "type": "List[str]",
              "description": "List of all the function addresses that were analyzed using the worker agents."
            },
            {
              "name": "interesting_functions",
              "type": "Dict[str, str]",
              "description": "Dictionary containing only the interesting functions as keys, and the reason why you find them interesting as value."
            },
            {
              "name": "executor_plan",
              "type": "str",
              "description": "A detailed plan for executor. This plan should contain the results of the binary analysis you performed, and what the executor agent needs to focus to solve the challenge."
            }
          ],
          "selected_tools": [],
          "max_tool_iterations": 30,
          "iteration_warning_message": "You are close to the tool iteration limit. Wrap up soon without more tool calls."
        }
      },
      {
        "id": "4",
        "type": "LLMNode",
        "label": "Executor",
        "config": {
          "title": "Executor",
          "input_state_keys": [
            "functions_visited",
            "interesting_functions"
          ],
          "output_state_keys": [
            "output_report"
          ],
          "system_prompt": "**Role:** You are the Lead CTF Executor. Your mission is to take a high-level reverse engineering plan and execute the technical steps required to retrieve the flag.\n\n**Input Context:**\nYou will receive:\n1. **functions_visited**: A list of functions already analyzed by the Orchestrator.\n2. **interesting_functions**: A dictionary of critical functions and their technical significance.\n3. **executor_plan**: The strategic roadmap you must follow.\n\n**Your Tools:**\n1. **executor_worker**: Use this tool for technical operations (disassembly, call graph analysis, or Python scripting). \n    - *Note:* The input you provide to this tool acts as its Human Message. Use imperative, technical commands.\n    - *Enhanced Capability:* This worker can run the binary with specific inputs to observe behavior.\n2. **run_challenge**: Use this tool to execute the challenge binary with a candidate input/payload to attempt flag retrieval.\n\n**Execution Protocol:**\n- **Refinement:** Use the `executor_worker` to extract specific constants, offsets, or logic details mentioned in the `executor_plan`.\n- **Computation:** Use `executor_worker`'s `run_python` to solve constraints (e.g., Z3), generate payloads, or reverse custom algorithms.\n- **Verification:** Test your solutions using `run_challenge`. If it fails, use the worker to debug the output and iterate.\n\n**Output Protocol:**\nOnce you have either retrieved the flag or exhausted all technical possibilities based on the plan, you must provide your final response in this format:\n\n- **output_report** (str): A comprehensive summary of your actions. \n    - If successful: Include the **flag** and a brief explanation of how it was obtained.\n    - If unsuccessful: Explain exactly where the process failed, what was attempted, and why the flag remained inaccessible.",
          "human_prompt": "### CTF Execution Phase: Flag Retrieval\n\n**Task:** You are now in the execution phase. Use the intelligence provided by the Orchestrator to interact with the binary and extract the flag.\n\n---\n### Global Context:\n**Functions Visited:** {{functions_visited}}\n\n**Interesting Functions:** {{interesting_functions}}\n\n**Executor Plan:** {{executor_plan}}\n---\n\n**Current Environment:** - You have access to the `executor_worker` for further analysis/scripting.\n- You have access to `run_challenge` to test inputs.\n\n**Instructions:** 1. Review the plan and identify the first technical hurdle. \n2. Use the worker to gather any missing data or solve the necessary logic.\n3. Attempt to retrieve the flag.\n4. When finished, provide your final **output_report**.\n\nPlease begin your first action.",
          "structured_output_schema": [
            {
              "name": "output_report",
              "type": "str",
              "description": "final report containing information obtained using the executor agent"
            }
          ],
          "selected_tools": [
            "run_challenge"
          ],
          "max_tool_iterations": 30,
          "iteration_warning_message": "You are close to the tool iteration limit. Wrap up soon without more tool calls."
        }
      }
    ],
    "edges": [
      {
        "from": "1",
        "to": "2",
        "target_slot": 0,
        "type": "NormalEdge"
      },
      {
        "from": "2",
        "to": "3",
        "target_slot": 0,
        "type": "NormalEdge"
      },
      {
        "from": "2",
        "to": "4",
        "target_slot": 0,
        "type": "NormalEdge"
      },
      {
        "from": "4",
        "to": "5",
        "target_slot": 0,
        "type": "NormalEdge"
      }
    ],
    "tools": {
      "list_functions": {
        "arguments": [],
        "description": "List all discovered functions from the challenge binary",
        "mcp_method": "GET /mcp/list_functions",
        "mcp_server": "http://mcp_binary:8002",
        "metadata": {
          "endpoint": "/mcp/list_functions",
          "method": "GET",
          "server_name": "binary_analysis"
        },
        "name": "list_functions",
        "return_schema": {
          "functions": "list",
          "success": "bool"
        },
        "type": "mcp"
      },
      "get_disassembly_by_function": {
        "arguments": [
          {
            "description": "Function name/signature",
            "name": "function",
            "required": true,
            "type": "str"
          }
        ],
        "description": "Fetch the disassembly for a specific function name",
        "mcp_method": "GET /mcp/get_disassembly_by_function",
        "mcp_server": "http://mcp_binary:8002",
        "metadata": {
          "endpoint": "/mcp/get_disassembly_by_function",
          "method": "GET",
          "server_name": "binary_analysis"
        },
        "name": "get_disassembly_by_function",
        "return_schema": {
          "disassembly": "str",
          "success": "bool"
        },
        "type": "mcp"
      },
      "get_caller_callee_mapping": {
        "arguments": [
          {
            "description": "Caller function name",
            "name": "function_signature",
            "required": true,
            "type": "str"
          }
        ],
        "description": "Return who a function calls within the binary",
        "mcp_method": "GET /mcp/get_caller_callee_mapping",
        "mcp_server": "http://mcp_binary:8002",
        "metadata": {
          "endpoint": "/mcp/get_caller_callee_mapping",
          "method": "GET",
          "server_name": "binary_analysis"
        },
        "name": "get_caller_callee_mapping",
        "return_schema": {
          "caller_callee_mapping": "dict",
          "success": "bool"
        },
        "type": "mcp"
      },
      "get_callee_caller_mapping": {
        "arguments": [
          {
            "description": "Callee function name",
            "name": "function_signature",
            "required": true,
            "type": "str"
          }
        ],
        "description": "Return which functions call the provided callee",
        "mcp_method": "GET /mcp/get_callee_caller_mapping",
        "mcp_server": "http://mcp_binary:8002",
        "metadata": {
          "endpoint": "/mcp/get_callee_caller_mapping",
          "method": "GET",
          "server_name": "binary_analysis"
        },
        "name": "get_callee_caller_mapping",
        "return_schema": {
          "callee_caller_mapping": "dict",
          "success": "bool"
        },
        "type": "mcp"
      },
      "run_challenge": {
        "arguments": [
          {
            "description": "Password to test",
            "name": "input",
            "required": true,
            "type": "str"
          }
        ],
        "description": "Execute the challenge binary with a candidate password",
        "mcp_method": "POST /mcp/run_challenge",
        "mcp_server": "http://mcp_binary:8002",
        "metadata": {
          "endpoint": "/mcp/run_challenge",
          "method": "POST",
          "server_name": "binary_analysis"
        },
        "name": "run_challenge",
        "return_schema": {
          "flag": "str",
          "output": "str",
          "success": "bool"
        },
        "type": "mcp"
      },
      "run_python": {
        "arguments": [
          {
            "description": "Python source to execute",
            "name": "code",
            "required": true,
            "type": "str"
          },
          {
            "description": "Optional STDIN for the script",
            "name": "stdin",
            "required": false,
            "type": "str"
          }
        ],
        "description": "Execute a Python snippet inside the challenge sandbox",
        "mcp_method": "POST /mcp/run_python",
        "mcp_server": "http://mcp_binary:8002",
        "metadata": {
          "endpoint": "/mcp/run_python",
          "method": "POST",
          "server_name": "binary_analysis"
        },
        "name": "run_python",
        "return_schema": {
          "return_code": "int",
          "stderr": "str",
          "stdout": "str",
          "success": "bool"
        },
        "type": "mcp"
      }
    }
  }
}